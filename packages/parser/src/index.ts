import babel from '@babel/core';
import fs from 'fs';
import path from 'path';
import glob from 'glob';
import { OutputOptions, rollup, RollupOptions } from 'rollup';
import nodeResolve from '@rollup/plugin-node-resolve';
import commonjs from '@rollup/plugin-commonjs';
import { terser } from 'rollup-plugin-terser';
import { Command } from 'commander';

const babelConfig = {
  presets: [['@babel/preset-env', { modules: false }]],
  plugins: ['@babel/plugin-transform-react-jsx'],
};

const program = new Command();

const generateCodeTemplate = (code: string): string => {
  return `
    /** @jsx ___createElement_leaf */
    import { createElementReactStyle as ___createElement_leaf } from '@leaf-web/core';
    
    // user code start
    ${code};
    // user code end
  `;
};

export const compileCode = (code: string): string => {
  return babel.transformSync(generateCodeTemplate(code), babelConfig)?.code || '';
};

export const transformFilename = (filename: string) => {
  const JSXExtensions = ['.jsx', '.tsx'];

  // transform file extension
  if (JSXExtensions.includes(path.extname(filename))) {
    return filename.substring(0, filename.length - 1);
  }
  return filename;
};

export const compileFile = (filePath: string, outputPath: string): string => {
  const code = fs.readFileSync(path.resolve(filePath)).toString();
  const result = compileCode(code);
  let absOutputPath = transformFilename(path.resolve(outputPath));

  fs.writeFileSync(absOutputPath, '// NOTE: This file is generated by Leafjs parser. DO NOT EDIT!\n\n' + result);
  return result;
};

export const compileFilesWithGlob = (pattern: string, outputDir: string) => {
  glob(pattern, (err, matches) => {
    if (err) {
      console.error(err);
      return;
    }

    matches.forEach((match) => {
      const currentPath = path.join(outputDir, match);
      const currentOutputDir = path.dirname(currentPath);

      fs.mkdir(currentOutputDir, { recursive: true }, (err) => {
        if (err) {
          console.error(err);
          return;
        }

        compileFile(match, currentPath);
      });
    });
  });
};

export const bundleFiles = async (entry: string, outputDir: string) => {
  const inputOptions: RollupOptions = {
    input: entry,
    plugins: [nodeResolve(), commonjs(), terser()],
  };
  const outputOptions: OutputOptions = {
    format: 'iife',
    file: path.join(outputDir, 'bundle.min.js'),
  };
  let bundle = null;

  try {
    bundle = await rollup(inputOptions);
    await bundle.write(outputOptions);
  } catch (err) {
    console.error(err);
  }

  if (bundle) {
    await bundle.close();
  }
};

export const buildFromConfig = async (configPath: string) => {
  const configContent = JSON.parse(fs.readFileSync(configPath).toString());

  compileFilesWithGlob(configContent.toBundle, configContent.outputDir);
  await bundleFiles(
    transformFilename(path.join(configContent.outputDir, configContent.entry)),
    configContent.outputDir
  );
};

program.name('leaf').description('Leafjs helper CLI.');

program
  .command('build')
  .description('Build and bundle a Leafjs application.')
  .option('-c, --config <string>', 'Config file location.', './leaf.config.json')
  .action(async (options) => {
    await buildFromConfig(options.config);
  });

program.parse();
