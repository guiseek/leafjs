class t{constructor(){this.activeEffects=[],this.targetMap=new WeakMap,this.onChange=null}getTrackableObject(t,e){for(const r in t)"object"==typeof t[r]&&(t[r]=this.getTrackableObject(t[r],e));const r=this,a=new Proxy(t,{get(t,r,a){const c=Reflect.get(t,r,a);return e.onGet(t,r,a),c},set(t,a,c,n){"object"==typeof c&&(c=r.getTrackableObject(c,e));const s=Reflect.set(t,a,c,n);return e.onSet(t,a,c,n),r.onChange&&r.onChange(),s},deleteProperty(t,r){const a=Reflect.deleteProperty(t,r);return e.onDeleteProperty(t,r),a}});return Array.isArray(t)&&Object.setPrototypeOf(a,Array.prototype),a}track(t,e){if(!this.activeEffects.length)return;let r=this.targetMap.get(t);r||(r=new Map,this.targetMap.set(t,r));let a=r.get(e);a||(a=new Set,r.set(e,a)),this.activeEffects.forEach((t=>null==a?void 0:a.add(t)))}trigger(t,e){const r=this.targetMap.get(t);if(!r)return;const a=r.get(e);a&&a.forEach((t=>{t()}))}watchEffect(t){this.activeEffects.push(t),t(),this.activeEffects.pop()}build(t){const e=this;return this.getTrackableObject(t,{onGet(t,r){e.track(t,r)},onSet(t,r){e.trigger(t,r)},onDeleteProperty(){}})}ref(t){const e=this,r={get value(){return e.track(r,"value"),t},set value(a){a!==t&&(t=a,e.trigger(r,"value"))}};return r}computed(t){const e=this.ref(null);return this.watchEffect((()=>e.value=t())),e}onStateChange(t){this.onChange=t,t()}}export{t as Reactive};
//# sourceMappingURL=reactivity.min.js.map
