"use strict";Object.defineProperty(exports,"__esModule",{value:!0});exports.Reactive=class{constructor(){this.activeEffects=[],this.targetMap=new WeakMap,this.onChange=null}getTrackableObject(t,e){for(const r in t)"object"==typeof t[r]&&(t[r]=this.getTrackableObject(t[r],e));const r=this,c=new Proxy(t,{get(t,r,c){const a=Reflect.get(t,r,c);return e.onGet(t,r,c),a},set(t,c,a,s){"object"==typeof a&&(a=r.getTrackableObject(a,e));const n=Reflect.set(t,c,a,s);return e.onSet(t,c,a,s),r.onChange&&r.onChange(),n},deleteProperty(t,r){const c=Reflect.deleteProperty(t,r);return e.onDeleteProperty(t,r),c}});return Array.isArray(t)&&Object.setPrototypeOf(c,Array.prototype),c}track(t,e){if(!this.activeEffects.length)return;let r=this.targetMap.get(t);r||(r=new Map,this.targetMap.set(t,r));let c=r.get(e);c||(c=new Set,r.set(e,c)),this.activeEffects.forEach((t=>null==c?void 0:c.add(t)))}trigger(t,e){const r=this.targetMap.get(t);if(!r)return;const c=r.get(e);c&&c.forEach((t=>{t()}))}watchEffect(t){this.activeEffects.push(t),t(),this.activeEffects.pop()}build(t){const e=this;return this.getTrackableObject(t,{onGet(t,r){e.track(t,r)},onSet(t,r){e.trigger(t,r)},onDeleteProperty(){}})}ref(t){const e=this,r={get value(){return e.track(r,"value"),t},set value(c){c!==t&&(t=c,e.trigger(r,"value"))}};return r}computed(t){const e=this.ref(null);return this.watchEffect((()=>e.value=t())),e}onStateChange(t){this.onChange=t,t()}};
//# sourceMappingURL=reactivity.min.js.map
